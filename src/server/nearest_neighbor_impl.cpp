// this program is automatically generated by jenerator. do not edit.
#include "../framework.hpp"
#include "nearest_neighbor_server.hpp"
#include "nearest_neighbor_serv.hpp"
using namespace jubatus;
using namespace jubatus::framework;
namespace jubatus { namespace server {
class nearest_neighbor_impl_ : public nearest_neighbor<nearest_neighbor_impl_>
{
public:
  nearest_neighbor_impl_(const server_argv& a):
    nearest_neighbor<nearest_neighbor_impl_>(a.timeout),
    p_(new server_helper<nearest_neighbor_serv>(a))
  { p_->use_cht();}

  bool set_config(const std::string& name, const config_data& config) //update broadcast
  { JWLOCK__(p_); return get_p()->set_config(config); }

  config_data get_config(const std::string& name) //analysis random
  { JRLOCK__(p_); return get_p()->get_config(); }

  bool init_table(const std::string& name) //update broadcast
  { JWLOCK__(p_); return get_p()->init_table(); }

  bool clear(const std::string& name) //update broadcast
  { JWLOCK__(p_); return get_p()->clear(); }

  bool set_row(const std::string& name, const std::string& id, const datum& d) //update cht(1)
  { JWLOCK__(p_); return get_p()->set_row(id, d); }

  neighbor_result neighbor_row_from_id(const std::string& name, const std::string& id, unsigned int size) //analysis random
  { JRLOCK__(p_); return get_p()->neighbor_row_from_id(id, size); }

  neighbor_result neighbor_row_from_data(const std::string& name, const datum& query, unsigned int size) //analysis random
  { JRLOCK__(p_); return get_p()->neighbor_row_from_data(query, size); }

  neighbor_result similar_row_from_id(const std::string& name, const std::string& id, int ret_num) //analysis random
  { JRLOCK__(p_); return get_p()->similar_row_from_id(id, ret_num); }

  neighbor_result similar_row_from_data(const std::string& name, const datum& query, int ret_num) //analysis random
  { JRLOCK__(p_); return get_p()->similar_row_from_data(query, ret_num); }

  bool save(const std::string& name, const std::string& id) //update broadcast
  { return get_p()->save(id); }

  bool load(const std::string& name, const std::string& id) //update broadcast
  { JWLOCK__(p_); return get_p()->load(id); }

  std::map<std::string, std::map<std::string, std::string > > get_status(const std::string& name) //analysis broadcast
  { JRLOCK__(p_); return p_->get_status(); }
  int run(){ return p_->start(*this); };
  common::cshared_ptr<nearest_neighbor_serv> get_p(){ return p_->server(); };
private:
  common::cshared_ptr<server_helper<nearest_neighbor_serv> > p_;
};
}} // namespace jubatus::server

int main(int args, char** argv){
  return
    jubatus::framework::run_server<jubatus::server::nearest_neighbor_impl_,
                                   jubatus::server::nearest_neighbor_serv>
       (args, argv, "nearest_neighbor");
}
